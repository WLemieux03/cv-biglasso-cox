beta <- beta.gn
p <- apply(beta, 2, function(b) alpha * sum(abs(b)) + (1 - alpha)/2 * sum(b^2))
nobs * lambda * p
##################### MINE ######################
### (l_obs1) first method
l_obs1 <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
num <- exp(x[i,] %*% beta)
den <- colSums(exp(x[R_ti,] %*% beta))
l_obs1[i,] <- y[i,"status"] * log(num/den)
}
### (l_obs1b) first.b method
l_obs1b <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
l_obs1b[i,] <- y[i,"status"] * (x[i,] %*% beta - log(colSums(exp(x[R_ti,] %*% beta))))
}
### (l_obs2) second method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs2 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[j])
den <- colSums(exp(x[R_idx,,drop=F] %*% beta))^d[j]
l_obs2[j,] <- log(num/den)
}
### (l_obs3) third method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs3 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (i in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[i]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[i])
den <- 1
for (j in 1:d[i]) {
den <- den * (
colSums(exp(x[R_idx,,drop=F] %*% beta)) - (j - 1)/d[i] * colSums(exp(x[D_idx,,drop=F] %*% beta))
)
}
l_obs3[i,] <- log(num/den)
}
### (l_obs4) fourth method (should be identical to the 2nd)
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs4 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
term1 <- colSums(x[D_idx,,drop=F]) %*% beta
R_idx <- (y[,"time"] >= dtime[j])
term2 <- log(colSums(exp(x[R_idx,,drop=F] %*% beta)))
l_obs4[j,] <- term1 - d[j] * term2
}
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[y[,"time"] == tau[j],,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
####################
l.bl <- fit.bl$loss/-2
l.gn <- (1-fit.gn$dev.ratio)*fit.gn$nulldev/-2
fit.cp$loglik
l.1 <- colSums(l_obs1)
l.2 <- colSums(l_obs2)
l.3 <- colSums(l_obs3)
l.4 <- colSums(l_obs4)
l.5 <- colSums(l_obs5)
plot(NA, xlab = expression(lambda), ylab = "Log-Likelihood", log = 'x',
xlim = range(lambda), ylim = range(l.1, l.2, l.3, l.bl, l.gn, l.5))
grid()
lines(l.bl ~ lambda, col = 'red')
lines(l.gn ~ lambda, col = 'blue')
lines(l.1 ~ lambda, col = 'purple')
lines(l.2 ~ lambda, col = 'orange')
lines(l.3 ~ lambda, col = 'darkgreen')
lines(l.4 ~ lambda, col = 'darkgreen')
lines(l.5 ~ lambda, col = 'black', lwd = 2, lty = 'dashed')
l.bl - l.gn
l.bl - l.3
l.gn - l.1
l.5/l.4
# create x matrix
set.seed(1)
nobs <- 100; nvars <- 10
x <- matrix(rnorm(nobs * nvars), nrow = nobs)
xbig <- bigmemory::as.big.matrix(x)
# create response
ty <- rep(rexp(nobs / 1), each = 1)
#ty <- rexp(nobs)
#ty[1:5] <- rep(ty[1], 5)
tcens <- rbinom(n = nobs, prob = 0.3, size = 1)
y <- cbind("time" = ty, "status" = tcens)
yS <- Surv(ty, tcens)
alpha <- 0.5
lambda <- exp(seq(-1, -6, length.out = 100))
fit.bl <- biglasso(xbig, yS, family = "cox", lambda = lambda, alpha = alpha, penalty = "enet")
fit.gn <- glmnet(x, yS, family = "cox", lambda = lambda, alpha = alpha)
fit.cp <- coxph(yS ~ x, ties = "breslow")
beta.bl <- as.matrix(fit.bl$beta)
beta.gn <- as.matrix(fit.gn$beta)
beta.cp <- as.matrix(fit.cp$coefficients)
beta <- beta.gn
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[y[,"time"] == tau[j],,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
l_obs5
colSums(l_obs5)
rowSums(l_obs5)
# create x matrix
set.seed(1)
nobs <- 100; nvars <- 10
x <- matrix(rnorm(nobs * nvars), nrow = nobs)
xbig <- bigmemory::as.big.matrix(x)
# create response
ty <- rep(rexp(nobs / 1), each = 1)
#ty <- rexp(nobs)
#ty[1:5] <- rep(ty[1], 5)
tcens <- rbinom(n = nobs, prob = 0.3, size = 1)
y <- cbind("time" = ty, "status" = tcens)
yS <- Surv(ty, tcens)
alpha <- 0.5
lambda <- exp(seq(-1, -6, length.out = 75))
fit.bl <- biglasso(xbig, yS, family = "cox", lambda = lambda, alpha = alpha, penalty = "enet")
fit.gn <- glmnet(x, yS, family = "cox", lambda = lambda, alpha = alpha)
fit.cp <- coxph(yS ~ x, ties = "breslow")
beta.bl <- as.matrix(fit.bl$beta)
beta.gn <- as.matrix(fit.gn$beta)
beta.cp <- as.matrix(fit.cp$coefficients)
beta <- beta.gn
p <- apply(beta, 2, function(b) alpha * sum(abs(b)) + (1 - alpha)/2 * sum(b^2))
nobs * lambda * p
##################### MINE ######################
### (l_obs1) first method
l_obs1 <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
num <- exp(x[i,] %*% beta)
den <- colSums(exp(x[R_ti,] %*% beta))
l_obs1[i,] <- y[i,"status"] * log(num/den)
}
### (l_obs1b) first.b method
l_obs1b <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
l_obs1b[i,] <- y[i,"status"] * (x[i,] %*% beta - log(colSums(exp(x[R_ti,] %*% beta))))
}
### (l_obs2) second method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs2 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[j])
den <- colSums(exp(x[R_idx,,drop=F] %*% beta))^d[j]
l_obs2[j,] <- log(num/den)
}
### (l_obs3) third method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs3 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (i in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[i]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[i])
den <- 1
for (j in 1:d[i]) {
den <- den * (
colSums(exp(x[R_idx,,drop=F] %*% beta)) - (j - 1)/d[i] * colSums(exp(x[D_idx,,drop=F] %*% beta))
)
}
l_obs3[i,] <- log(num/den)
}
### (l_obs4) fourth method (should be identical to the 2nd)
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs4 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
term1 <- colSums(x[D_idx,,drop=F]) %*% beta
R_idx <- (y[,"time"] >= dtime[j])
term2 <- log(colSums(exp(x[R_idx,,drop=F] %*% beta)))
l_obs4[j,] <- term1 - d[j] * term2
}
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[y[,"time"] == tau[j],,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
l_obs5
colSums(l_obs5)
cbind(y[,"time"] == tau[1])
cbind(y[,"time"] == tau[1], y[,"status"])
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[(y[,"time"] == tau[j]) * y[,"status"],,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
colSums(l_obs5)
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[(y[,"time"] == tau[j]) & (y[,"status"] == 1),,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
colSums(l_obs5)
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
S <- colSums(x[y[,"time"] == tau[j],,drop=F])
l_obs5[j,] <- S %*% beta - d[j] * log(colSums(exp(x[R_tau,,drop=F] %*% beta)))
}
colSums(l_obs5)
j <- 1
R_tau <- y[,"time"] >= tau[j]
D_j <- y[,"time"] == tau[j]
D_j
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
tau[1]
R_tau <- y[,"time"] >= tau[j]
j <- 1
R_tau <- y[,"time"] >= tau[j]
D_j <- y[,"time"] == tau[j]
D_j
tau[j]
y[,"time"]
y[,"time"]-tau[j]
y[,"time"]-tau[j] == 0
y[,"time"]==tau[j]
x[D_j,]
x[D_j,,drop=F]
x[D_j,,drop=F] %*% beta
colSums(x[D_j,,drop=F]) %*% beta
num <- exp(colSums(x[D_j,,drop=F]) %*% beta)
num
colSums(exp(x[R_tau,,drop=F] %*% beta))
den <- colSums(exp(x[R_tau,,drop=F] %*% beta))^d[j]
den
d[j]
# create x matrix
set.seed(1)
nobs <- 100; nvars <- 10
x <- matrix(rnorm(nobs * nvars), nrow = nobs)
xbig <- bigmemory::as.big.matrix(x)
# create response
ty <- rep(rexp(nobs / 1), each = 1)
#ty <- rexp(nobs)
#ty[1:5] <- rep(ty[1], 5)
tcens <- rbinom(n = nobs, prob = 0.3, size = 1)
y <- cbind("time" = ty, "status" = tcens)
yS <- Surv(ty, tcens)
alpha <- 0.5
lambda <- exp(seq(-1, -6, length.out = 75))
fit.bl <- biglasso(xbig, yS, family = "cox", lambda = lambda, alpha = alpha, penalty = "enet")
fit.gn <- glmnet(x, yS, family = "cox", lambda = lambda, alpha = alpha)
fit.cp <- coxph(yS ~ x, ties = "breslow")
beta.bl <- as.matrix(fit.bl$beta)
beta.gn <- as.matrix(fit.gn$beta)
beta.cp <- as.matrix(fit.cp$coefficients)
beta <- beta.gn
p <- apply(beta, 2, function(b) alpha * sum(abs(b)) + (1 - alpha)/2 * sum(b^2))
nobs * lambda * p
##################### MINE ######################
### (l_obs1) first method
l_obs1 <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
num <- exp(x[i,] %*% beta)
den <- colSums(exp(x[R_ti,] %*% beta))
l_obs1[i,] <- y[i,"status"] * log(num/den)
}
### (l_obs1b) first.b method
l_obs1b <- matrix(NA, nrow = nrow(y), ncol = length(lambda))
for (i in 1:nrow(y)) {
ti <- y[i,"time"]
R_ti <- (y[,"time"] >= ti) # Risk set (set of subjects at risk at time t_i)
l_obs1b[i,] <- y[i,"status"] * (x[i,] %*% beta - log(colSums(exp(x[R_ti,] %*% beta))))
}
### (l_obs2) second method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs2 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[j])
den <- colSums(exp(x[R_idx,,drop=F] %*% beta))^d[j]
l_obs2[j,] <- log(num/den)
}
### (l_obs3) third method
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs3 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (i in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[i]) & (y[,"status"] == 1)
num <- exp(colSums(x[D_idx,,drop=F]) %*% beta)
R_idx <- (y[,"time"] >= dtime[i])
den <- 1
for (j in 1:d[i]) {
den <- den * (
colSums(exp(x[R_idx,,drop=F] %*% beta)) - (j - 1)/d[i] * colSums(exp(x[D_idx,,drop=F] %*% beta))
)
}
l_obs3[i,] <- log(num/den)
}
### (l_obs4) fourth method (should be identical to the 2nd)
d <- as.numeric(table(y[y[,2] == 1,1])) # table of failure times for y[,"status"] == 1 obs.
dtime <- sort(unique(y[y[,2] == 1,1])) # unique failure times for y[,"status"] == 1 obs.
l_obs4 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:length(d)) {
D_idx <- (y[,"time"] == dtime[j]) & (y[,"status"] == 1)
term1 <- colSums(x[D_idx,,drop=F]) %*% beta
R_idx <- (y[,"time"] >= dtime[j])
term2 <- log(colSums(exp(x[R_idx,,drop=F] %*% beta)))
l_obs4[j,] <- term1 - d[j] * term2
}
### (l_obs5) fifth method...
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
D_j <- y[,"time"] == tau[j]
num <- exp(colSums(x[D_j,,drop=F]) %*% beta)
den <- colSums(exp(x[R_tau,,drop=F] %*% beta))^d[j]
l_obs5[j,] <- num/den
}
apply(l_obs5, 2, function(x) prod)
l_obs5
str(l_obs5)
apply(l_obs5, 2, prod)
apply(l_obs5, 1, prod)
apply(l_obs5, 1, prod)
apply(l_obs5, 2, prod)
log(apply(l_obs5, 2, prod))
apply(l_obs5, 1, sum)
apply(l_obs5, 2, sum)
ytab <- table(y[,"time"])
d <- as.numeric(ytab)
tau <- as.numeric(sort(unique(y[,"time"])))
K <- length(tau)
l_obs5 <- matrix(NA, nrow = length(d), ncol = length(lambda))
for (j in 1:K) {
R_tau <- y[,"time"] >= tau[j]
D_j <- y[,"time"] == tau[j]
num <- exp(colSums(x[D_j,,drop=F]) %*% beta)
den <- colSums(exp(x[R_tau,,drop=F] %*% beta))^d[j]
l_obs5[j,] <- log(num/den)
}
apply(l_obs5, 2, sum)
?grepl
?coxph
x <- c(100, 10,  6, 2) # distance (feet)
y <- c(21, 60, 80, 93) # drag reduc
plot(y ~ x)
FD <- function(rho, v, CD, A) { # force of drag
# rho = fluid density (kg/m^3)
# v   = speed relative to fluid (m/s)
# CD  = coefficient of drag (dimensionless)
# A   = cross-sectional area (m^2)
#
# FD  = force of drag (N = kg*m/s^2)
0.5 * rho * v * v * CD * A
}
log(0.001)
seq(log(0.001), log(2.000), length.out = 10)
exp(seq(log(0.001), log(2.000), length.out = 10))
A <- seq(0.5, 5, by = 0.5)
A
v <- seq(0, 30, length.out = 10)
CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
A <- seq(1, 5, length.out = 10)
X <- expand.grid(v, CD)
X
X <- expand.grid(v, CD, A)
X
str(X)
Y <- apply(X, 1, function(x) FD(rho = 1.225, v = x[1], CD = x[2], A = x[3]))
str(Y)
?outer
Y <- outer(CD, A, FUN = function(x1, x2) FD(rho = 1.225, v = 1, CD = x1, A = x2))
Y
fields::image.plot(CD, A, Y, col = pals::parula(124))
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CD <- seq(0.001, 2.000, length.out = 10)
A <- seq(1, 5, length.out = 10)
FD(rho = 1.225, v = v, CD = CD, A = A)
Y <- outer(CD, A, FUN = function(x1, x2) FD(rho = 1.225, v = 1, CD = x1, A = x2))
fields::image.plot(CD, A, Y, col = pals::parula(124))
fields::image.plot(CD, A, Y, col = pals::parula(129))
fields::image.plot(CD, A, Y, col = pals::parula(65))
fields::image.plot(CD, A, Y, col = pals::parula(33))
fields::image.plot(CD, A, Y, col = pals::parula(32))
fields::image.plot(CD, A, Y, col = pals::parula(64))
persp(CD, A, Y)
v <- seq(0, 30, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CD <- seq(0.001, 2.000, length.out = 50)
A <- seq(1, 5, length.out = 50)
Y <- outer(CD, A, FUN = function(x1, x2) FD(rho = 1.225, v = 1, CD = x1, A = x2))
fields::image.plot(CD, A, Y, col = pals::parula(64))
persp(CD, A, Y)
fields::image.plot(CD, A, Y, col = pals::parula(64))
FD1 <- function(rho, v, CD, A) { # force of drag
# rho = fluid density (kg/m^3)
# v   = speed relative to fluid (m/s)
# CD  = coefficient of drag (dimensionless)
# A   = cross-sectional area (m^2)
#
# FD  = force of drag (N = kg*m/s^2)
0.5 * rho * v * v * CD * A
}
FD2 <- function(rho, v, CDA) { # force of drag
# rho = fluid density (kg/m^3)
# v   = speed relative to fluid (m/s)
# CDA  = coefficient of drag * cross-sectional area (m^2)
#
# FD  = force of drag (N = kg*m/s^2)
0.5 * rho * v * v * CDA
}
FD <- function(rho, v, CD, A) { # force of drag
# rho = fluid density (kg/m^3)
# v   = speed relative to fluid (m/s)
# CD  = coefficient of drag (dimensionless)
# A   = cross-sectional area (m^2)
#
# FD  = force of drag (N = kg*m/s^2)
0.5 * rho * v * v * CD * A
}
CDA <- seq(0.1, 1, length.out = 50)
v <- seq(0, 30, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CD <- seq(0.001, 2.000, length.out = 50)
A <- seq(1, 5, length.out = 50)
CDA <- seq(0.1, 1, length.out = 50)
v <- seq(0, 30, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CD <- seq(0.001, 2.000, length.out = 50)
A <- seq(1, 5, length.out = 50)
CDA <- seq(0.1, 1, length.out = 50)
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
persp(CD, A, Y)
v <- seq(0, 30, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CDA <- seq(0.1, 1, length.out = 70)
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
persp(CD, A, Y)
Y
str(Y)
persp(v, CDA, Y)
fields::image.plot(v, CDA, Y, col = pals::parula(64))
v <- seq(0, 100, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CDA <- seq(0.1, 2, length.out = 70)
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
v <- seq(0, 100, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CDA <- exp(seq(log(0.001), log(10), length.out = 70))
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
v <- seq(0, 100, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CDA <- seq(0.001, 10, length.out = 70)
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
v <- seq(0, 50, length.out = 50)
#CD <- exp(seq(log(0.001), log(2.000), length.out = 10))
CDA <- seq(0.001, 10, length.out = 70)
Y <- outer(v, CDA, FUN = function(vv, AA) FD(rho = 1.225, v = vv, CD = 1, A = AA))
fields::image.plot(v, CDA, Y, col = pals::parula(64))
